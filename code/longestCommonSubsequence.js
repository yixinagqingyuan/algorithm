/** @format */

// 最长公共子序列
const longestCommonSubsequence = (str1, str2) => {
  // 这个题的叫动态规划，本质是弄一个二维数组，如果在这个二维数组中，放的就是，相等的公共的值
  // 这样使用动态规划，就能在最后的一个位置，拿到最长的公共子序列，之所以就是最长的
  // 就是因为我们在遍历的过程中，就会去比较，在每次一都拿到最大的
  // 所以我们需要先做一件事情，就是要先弄一个 dp 的二维数组
  // const dp = new Array(str1.length + 1).fill(new Array(str2.length + 1).fill(0))
  // 还有一个写法，利用  Array.from 方法就能解决问题 最后返回的是一个二维数组
  const dp = Array.from(new Array(str1 + 1), () => new Array(str2 + 1).fill(0))
  // 而之所以最后要+1 是因为我们直接从 1 开始就行 ，而之所以要从 1 开始，是因为，他的公式是有 n-1
  // 但是我从头开始哪里有 n-1 呢？ 所以我还不如直接从 1 开始
  // 于是开始双重 for 循环 来处理公共的情况
  for (let i = 1; i <= str1; i++) {
    for (let j = 1; j <= str2; j++) {
      // 因为开始是从 1 开始 所以我们需要从 i-1 开始
      // 这样是为了 从头开始能遍历到初始化的情况
      if (str1[i - 1] == str2[j - 1]) {
        // 这个情况说明是公共的，要+1
        // 但是从哪+1 这是个问题，我们只需要从 dp[i-1][j-1] 已经动态规划过的值加上 1 就行
        // 因为 dp[i-1][j-1] 就是遍历上一个的地方 相等的情况
        dp[i][j] = dp[i - 1][j - 1] + 1
      } else {
        // 如果不想等，那么就求一个最大值，也就是dp[i - 1] dp[j]和dp[i][j - 1] 的这两个地方的最大值，取一个就行
        // 之所以为什么要这么取呢，就是我遍历到这了，我有没法找到之前的状态，只能将已有的状态平移过来，但是此时有两个地方的两种情况
        // 所以我需要取一个最大值，这样才能保证我能拿到最大值
        dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1])
      }
    }
  }
  return dp[str1.length][str2.length]
}

longestCommonSubsequence('abcde', 'ace')
