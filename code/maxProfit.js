/** @format */

// 买卖股票的最佳时机

// 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

// 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。
const maxProfit = (prices) => {
  // 这道题用贪心算法做最合理，为啥呢？
  // 所谓贪心算法，就是局部最优解，来达到全局最优解，
  // 而我们当前这一题，用贪心算法，就是再合适不过了，因为，我们只需要每次遍历的时候找到最小值，然后再用当前的值减去最小的值，然后就能求出最大的差价
  // 既然min 是最小值，那么由于要比较，如此一来， 我们直接赋第一个就行了
  let min = prices[0]
  let max = 0
  for (var i = 0; i < prices.length - 1; i++) {
    // 首先我们找到当前情况下的最小值，当然后续还有更小的
    min = Math.min(prices[i], min)
    // 此时已经找到当前的已经遍历的最小的了，然后我们要求最大差价了
    // 怎么求呢，就是用当前的值，减去之前的的最小的值，然后的插件就跟之前的最大的差价去比，这样就能拿到最大的差价了
    // 而之所以要用这种方式求最大值，还有一个原因，就是有一个顺序问题，求最大值，必须要有顺序，也就是要用后头的减去前头的
    // 所以这个思路真的是非常好
    max = Math.max(max, prices[i] - min)
  }
  console.log(max)
}

// 买卖股票的最佳时机II
//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。
//设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。
//注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。
const maxProfit1 = (prices) => {
  // 这一题说的是完成更多的交易，并且完成更多的交易
  // 这个时候，我们还要要挣很多钱，那么就可以很粗暴的用贪心算法来解决
  // 也就是他只要挣钱的时候，我们就可以去交易，这样就保证了
  // 我既完成可更多的交易，也挣了更多的钱，都满足了
  let max = 0
  for (let i = 0; i < prices.length - 1; i++) {
    // 这时候需要来一个 if 判断只要挣钱了，我们就给他卖了
    if (prices[i] < prices[i + 1]) {
      // 这时候直接累加赚到的差价就行
      max += prices[i + 1] - prices[i]
    }
  }
  console.log(max)
}
maxProfit1([1, 2, 3, 4, 5])

// 买卖股票的最佳时机III
//给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。
//设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易。
//注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

const maxProfit2 = (prices) => {}
