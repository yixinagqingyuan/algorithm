/** @format */

//我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第n个丑数。
//输入: n = 10
//输出: 12
//解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数。
const ugly = (n) => {
  // 首先要求前十个丑数，因为 1 是特殊的
  const res = [1] // 我们先给他糊弄进来
  // 然后我们搞一个在当前的 res 的基础上来解决 乘以一个数字，来取最后的前n个
  // 他最终还是 2^x*3^x*5^x这一套
  let p1 = 0
  let p2 = 0
  let p3 = 0
  // 然后遍历，来往 res 里头push
  for (let i = 1; i < n.length; i++) {
    // 为什么从 1 开始，因为1是特殊的丑数
    // 取一个丑数的最小值
    const min = Math.min(2 * res[p1], 3 * res[p2], 5 * res[p3])
    // 给塞进去
    res.push(min)
    // 这一步就是为了判断我要添加p1 还是p2 还是 p3,主要因为都是倍数，所以只需要按照倍数找就行了
    if (min == 2 * res[p1]) {
      p1++
    } else if (min == 3 * res[p2]) {
      p2++
    } else if (min == 5 * res[p3]) {
      p3++
    }
  }
}

ugly(10)

// 这个破套路重写一遍
const ugly1 = (n) => {
  // 这个题的主要思路是啥就是先搞清楚什么是丑数，什么是丑数，包含 2 3 5 的数 ， 注意这里是包含 2 或者 3 或者 5，那就好办了
  // 所以首先我们要给搞个结果集合，注意，1 是特殊的丑数，所以我们上来要先给他搞进去
  const res = [1]
  // 然后我们需要搞几个数，来分别做 235 的乘积，这么做是为什么呢? 原因很简单，分别要被这三个数整除啊
  // 所以我当然要搞个这三个数的乘积，然后从小到大找到这个数啊
  let p0 = 0
  let p1 = 0
  let p2 = 0
  // 当然，上来先得 for 循环
  for (let i = 0; i < n; i++) {
    // 这时候细节来了，我要找到最小的，因为要排序啊 ,因为是包含 235 所以，他一定要是找到当前数组里头最小的来乘积，如果这个最小的乘以某个数被用过了，那就需要加一个，因为上一个数乘以 2 或者 3 或者 5 已经用过了
    // 其实说白了，就是利用这三个占位变量，给每一个以前的丑数分别乘以 2 3 5
    const min = Math.min(res[p0] * 2, res[p1] * 3, res[p2] * 5)
    // 拿到最小值，接下来，就该 push
    res.push(min)
    // 然后就要乘以倍数来来解决问题了
    if (min == res[p0] * 2) {
      p0++
    } else if (min == res[p1] * 3) {
      p1++
    } else {
      p2++
    }
  }
}
