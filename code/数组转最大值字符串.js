/** @format */

// 输入：nums = [3,30,34,5,9]
//输出："9534330"

const arrayToMaxString = (nums) => {
  // 使用特殊的排序规则：比较两个数字字符串拼接后的大小
  // 例如比较 3 和 30：
  // 330 vs 303，330更大，所以30应该在3前面
  return nums
    .sort((a, b) => {
      const order1 = `${a}${b}`
      const order2 = `${b}${a}`
      return order2 - order1 // 降序排序
    })
    .join('') // 将排序后的数组连接成字符串
}

// 测试用例
console.log(arrayToMaxString([3, 30, 34, 5, 9])) // 输出："9534330"

const arrayToMaxString1 = (nums) => {
  //这个有意思的地方就是比较大小啊，也就是我组合两个数字，然后最后安上一个数字，比较大小
  // 这个利用什么解决呢？ 其实说白了也是两个连起来比大小这样做的好处试是什么呢？
  // 举个例子，3 和 30 比较，330 和 303 比较，330 肯定是大于 303 的 ，也就是如果局的数字如果大，那最终排出来的数字一定也大，最终只要按照位数去比较就行了
  // 其实本质上就是动态规划，通过一次次的局部比较，得到每个位置的正确答案，最后得到最大的答案,
  // 代码层面其实就是一个个双重 for 循环的比较，其他位置补 0 的比较
  // 所以局部的组合答案最后得到的就是整体组合答案
  // 我们开始
  nums.sort((a, b) => {
    const v1 = `${a}${b}`
    const v2 = `${b}${a}`
    return v2 - v1
  })
  return nums.join('')
}
