/** @format */

//最大子数组和
//给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
//输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
//输出：6
//解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

// 这一题很好搞，动态规划

const MaxSubSum3 = (nums) => {
  // 这一道题用动态规划开始，我应该怎么做呢？
  // 首先高动态规划得有 dp，然后因为你要求最大值，还要有 max
  let dp, max
  for (let i = 0; i < nums.length; i++) {
    // 然后我们就要干什么事情呢，就是要求 dp每一个层级 dp 里头的值，但是这值因为你要求最大值啊，所以要跟 0 去做一个最比
    // 如果都比 0 小了当然要从 0 开始啊，相当于从头开始排列
    dp = Math.max(dp, 0) + nums[i]
    // 然后就要在所有 dp 里头找到最大值
    max = Math.max(max, dp)
  }
  return max
}

// 重写一次这种的动态规划，这种题很简单，动态规划一次搞定

const maxsum = (nums) => {
  // 这一题的思路是动态规划，怎么做呢？很简单，我们只需要知道 搞个 dp 就可以了，然后呢？
  // 他不是要求最大值吗？ 所以呢，只要我最后求得值比当前值大不就行了吗，或者一下给他干成负的，我就从o 开始啊，相当于从头开始排列
  let dp = 0
  let max = 0
  for (let i = 0; i < nums.length; i++) {
    // 这个就很巧妙因为是连续的吗，我最后如果加上一个小的值，只要他不小于0 那就没必要从头开始，因为后后续连续的时候，还有可能加上一个变成最大，为什么这样可以
    // 如果加上一个负值不管你前面前面舍弃掉什么，怎么组合，他前面是正的值，都不可能比最开始累加的大
    // 所以 dp 就是这种类型
    dp = Math.max(0, dp) + nums[i]
    // 接下来动态规划的求最大值就可以了
    max = Math.max(dp, max)
  }
  return max
}
