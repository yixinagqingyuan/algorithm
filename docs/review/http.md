<!-- @format -->

# 网络协议热门考题

## 1、HTTP 1.0 和 2.0 有什么区别？

HTTP 1.0 和 HTTP 2.0 是两种不同的超文本传输协议版本，它们在性能、传输方式和功能上有显著的区别。以下是它们的主要差异：

---

### **1. 连接方式**

| **版本**     | **连接方式**                                                                                          |
| ------------ | ----------------------------------------------------------------------------------------------------- |
| **HTTP 1.0** | 每个请求/响应使用一个独立的 TCP 连接，即**短连接**。请求完成后连接关闭，需要频繁建立和断开连接。      |
| **HTTP 2.0** | 使用**单个长连接**，支持**多路复用**，即在一个 TCP 连接上并行传输多个请求和响应，减少连接开销和延迟。 |

---

### **2. 多路复用**

| **版本**     | **特点**                                                                                         |
| ------------ | ------------------------------------------------------------------------------------------------ |
| **HTTP 1.0** | 同时只能发送一个请求，必须等待前一个请求完成后才能发送下一个（**线性传输，队头阻塞**）。         |
| **HTTP 2.0** | 支持**多路复用**，同一连接可以发送多个请求和响应，无需按顺序等待，消除了队头阻塞，提高传输效率。 |

---

### **3. 数据传输格式**

| **版本**     | **传输格式**                                                                         |
| ------------ | ------------------------------------------------------------------------------------ |
| **HTTP 1.0** | 传输纯文本（ASCII），没有优化数据传输的机制。                                        |
| **HTTP 2.0** | 使用**二进制格式**（Binary Framing），更加紧凑和高效，支持更快的解析和更低的错误率。 |

---

### **4. 压缩和传输效率**

| **版本**     | **特性**                                                                      |
| ------------ | ----------------------------------------------------------------------------- |
| **HTTP 1.0** | 不支持对头部和数据的压缩，导致传输效率较低，尤其是对于冗长的 HTTP 头部信息。  |
| **HTTP 2.0** | 支持**头部压缩**（HPACK），大大减少头部大小；同时支持流量控制，提高传输效率。 |

---

### **5. 服务器推送**

| **版本**     | **特点**                                                                                          |
| ------------ | ------------------------------------------------------------------------------------------------- |
| **HTTP 1.0** | 不支持服务器主动推送资源，客户端必须明确发起请求。                                                |
| **HTTP 2.0** | 支持**服务器推送**功能，可以主动向客户端发送可能需要的资源（如 CSS、JS 文件），减少后续请求延迟。 |

---

### **6. 加密支持**

| **版本**     | **特点**                                         |
| ------------ | ------------------------------------------------ |
| **HTTP 1.0** | 默认不支持加密，但可以结合 SSL/TLS 实现 HTTPS。  |
| **HTTP 2.0** | 默认需要加密连接（基于 TLS），提供更高的安全性。 |

---

### **7. 请求头优化**

| **版本**     | **特点**                                                                      |
| ------------ | ----------------------------------------------------------------------------- |
| **HTTP 1.0** | 请求头信息会在每次请求中重复发送，带来额外的带宽开销。                        |
| **HTTP 2.0** | 使用头部压缩（HPACK）和头部信息复用机制，减少重复头部的传输，提升带宽利用率。 |

---

### **8. 性能对比**

| **性能方面**     | **HTTP 1.0**                             | **HTTP 2.0**                               |
| ---------------- | ---------------------------------------- | ------------------------------------------ |
| **连接建立时间** | 频繁的 TCP 连接建立与关闭增加延迟。      | 单个长连接减少握手开销，降低延迟。         |
| **并发能力**     | 每次只能处理一个请求，存在队头阻塞问题。 | 支持并行传输多个请求和响应，性能显著提升。 |
| **资源加载**     | 客户端必须逐个请求资源。                 | 支持服务器主动推送资源，优化加载速度。     |
| **带宽利用**     | 无压缩机制，浪费带宽。                   | 头部压缩与二进制传输减少带宽占用。         |

---

### **9. 实际应用**

| **特点**     | **HTTP 1.0**                             | **HTTP 2.0**                                                                       |
| ------------ | ---------------------------------------- | ---------------------------------------------------------------------------------- |
| **使用场景** | 适用于早期的简单网页交互和少量资源加载。 | 适用于现代复杂应用和需要高效资源加载的网页，尤其是对性能要求较高的场景（如 SPA）。 |
| **兼容性**   | 支持所有浏览器和旧版服务器。             | 需要现代浏览器支持，服务器也需要支持 HTTP/2 协议。                                 |

---

### **10. 总结**

| **对比点**   | **HTTP 1.0**     | **HTTP 2.0**             |
| ------------ | ---------------- | ------------------------ |
| **连接模式** | 短连接           | 长连接，多路复用         |
| **传输格式** | 文本格式         | 二进制格式               |
| **队头阻塞** | 存在             | 多路复用消除了队头阻塞   |
| **头部处理** | 无压缩，头部重复 | HPACK 压缩头部           |
| **安全性**   | 可选支持 HTTPS   | 默认支持加密（基于 TLS） |
| **性能**     | 效率较低         | 高效，适用于复杂场景     |

---

### **推荐使用**

- 如果服务器和客户端都支持 HTTP/2，优先使用 HTTP/2。
- HTTP/1.0 更适用于简单或早期应用，但现代网站几乎都已经迁移到 HTTP/2 或 HTTP/3（基于 QUIC 协议）。

## 2、到底什么是 TCP 连接？

### **TCP 连接的定义**

TCP（**Transmission Control Protocol**，传输控制协议）是网络通信的核心协议之一，用于在两台计算机之间建立可靠的通信连接。它提供了一个**面向连接**、**可靠的字节流传输服务**，保证数据在不丢失、不重复、按顺序的情况下从一端传输到另一端。

一个 **TCP 连接** 就是通过 TCP 协议在两台计算机之间建立起来的数据传输通道。

---

### **TCP 连接的特性**

1. **面向连接**
   - 在传输数据之前，必须通过 **三次握手** 建立连接，确保双方都准备好收发数据。
2. **可靠性**

   - TCP 确保数据包的传输是可靠的，发送的数据会被确认（ACK），丢失的数据会被重新发送。

3. **按序传递**

   - TCP 会为数据分配序号，接收方按照序号重组数据，确保数据包按照正确顺序到达。

4. **流量控制**

   - TCP 会根据网络情况调整发送数据的速度，防止发送方过快导致接收方处理不过来。

5. **全双工通信**
   - TCP 支持双向同时传输数据，发送方和接收方都可以同时进行数据传输。

---

### **TCP 连接的建立过程**

TCP 连接是通过 **三次握手（Three-way Handshake）** 建立的，这个过程确保通信双方都能正常发送和接收数据。

#### **三次握手的步骤**：

1. **第一步：客户端发送 SYN**

   - 客户端发送一个带有 `SYN`（synchronize，同步）标志的数据包，表示希望建立连接，同时发送一个初始序列号。
   - 客户端状态：`SYN_SENT`。

2. **第二步：服务器响应 SYN-ACK**

   - 服务器接收到客户端的 SYN 后，向客户端发送一个带有 `SYN` 和 `ACK`（acknowledge，确认）标志的数据包，表示接收到请求并同意建立连接。
   - 服务器状态：`SYN_RCVD`。

3. **第三步：客户端发送 ACK**
   - 客户端接收到服务器的 `SYN-ACK` 后，再发送一个带有 `ACK` 标志的数据包，确认收到服务器的响应，至此连接建立完成。
   - 客户端和服务器状态：`ESTABLISHED`（连接已建立）。

---

### **TCP 连接的断开过程**

TCP 连接通过 **四次挥手（Four-way Handshake）** 断开，以保证双方都确认连接的关闭。

#### **四次挥手的步骤**：

1. **第一步：主动关闭方发送 FIN**

   - 主动方发送一个带有 `FIN`（finish，结束）标志的数据包，表示要关闭连接。
   - 主动关闭方状态：`FIN_WAIT_1`。

2. **第二步：被动关闭方回复 ACK**

   - 被动方接收到 `FIN` 后，返回一个 `ACK` 数据包，表示确认收到关闭请求。
   - 被动关闭方状态：`CLOSE_WAIT`。

3. **第三步：被动关闭方发送 FIN**

   - 被动方在处理完未完成的数据传输后，也发送一个 `FIN` 数据包，表示同意关闭连接。
   - 主动关闭方状态：`FIN_WAIT_2`。

4. **第四步：主动关闭方回复 ACK**
   - 主动方收到 `FIN` 后，发送 `ACK` 数据包，表示确认关闭连接。
   - 双方状态：`CLOSED`（连接关闭）。

---

### **TCP 连接的作用**

1. **确保数据完整性**

   - 数据在传输过程中可能丢失、重复或乱序，TCP 的确认机制、重传机制和序列号可以解决这些问题。

2. **提供可靠通信**

   - TCP 保证数据无差错且按照顺序到达，适用于需要可靠性较高的应用，如文件传输、网页加载、电子邮件等。

3. **实现流量控制和拥塞控制**
   - TCP 动态调整数据传输速度，避免网络拥塞，保护传输质量。

---

### **TCP 连接的典型应用**

- **HTTP/HTTPS**：用于网页浏览和数据加载（例如 HTTP/2 协议依赖 TCP）。
- **FTP**：文件传输协议。
- **SMTP/IMAP/POP3**：用于电子邮件的收发。
- **SSH**：远程登录和数据传输。
- **实时应用**：一些实时通信应用（如聊天工具）使用 TCP 来保证消息的完整性。

---

### **TCP 和 UDP 的对比**

| **特点**     | **TCP**（传输控制协议）                  | **UDP**（用户数据报协议）            |
| ------------ | ---------------------------------------- | ------------------------------------ |
| **连接**     | 面向连接（需建立连接，三次握手）         | 无连接（无需建立连接）               |
| **可靠性**   | 提供可靠传输（确认机制、重传机制、排序） | 不提供可靠传输（无确认、不保证顺序） |
| **速度**     | 较慢（因为有连接和可靠性机制的开销）     | 较快（无连接、轻量级）               |
| **应用场景** | 文件传输、网页浏览、邮件、聊天等         | 视频直播、在线游戏、语音通话等       |

---

### **总结**

- **TCP 连接**是基于传输控制协议在通信双方之间建立的一种可靠的网络连接。
- 它通过三次握手建立连接，通过四次挥手断开连接，确保数据传输的可靠性、完整性和有序性。
- TCP 连接广泛应用于对数据完整性要求较高的场景，如文件传输、网页浏览和电子邮件通信。

## 3、TCP 和 UDP 有什么区别？

TCP 和 UDP 是网络传输层的两种主要协议，它们各有特点，适用于不同的应用场景。以下是它们的主要区别：

---

### **1. 面向连接 vs 无连接**

| **特性**     | **TCP**                                                          | **UDP**                      |
| ------------ | ---------------------------------------------------------------- | ---------------------------- |
| **连接模式** | 面向连接（Connection-oriented）                                  | 无连接（Connectionless）     |
| **描述**     | 在传输数据之前，需要通过三次握手建立连接，保证通信双方准备就绪。 | 无需建立连接，直接发送数据。 |

---

### **2. 可靠性**

| **特性**     | **TCP**                       | **UDP**                        |
| ------------ | ----------------------------- | ------------------------------ |
| **可靠性**   | 提供可靠的数据传输。          | 不保证数据可靠传输。           |
| **具体表现** | - 数据传输有确认机制（ACK）。 | - 数据可能丢失、不按顺序到达。 |
|              | - 有重传机制确保数据完整性。  | - 无数据重传机制。             |
|              | - 提供流量控制和拥塞控制。    | - 不提供流量控制或拥塞控制。   |

---

### **3. 数据传输方式**

| **特性**     | **TCP**                                        | **UDP**                                            |
| ------------ | ---------------------------------------------- | -------------------------------------------------- |
| **传输模式** | 面向字节流（Stream-oriented）。                | 面向报文（Message-oriented）。                     |
| **描述**     | 数据被分成字节流传输，接收方需按顺序组装数据。 | 数据以独立的报文形式发送，每个报文是一个完整单元。 |
| **传输顺序** | 保证数据按顺序到达。                           | 不保证数据顺序，可能乱序或丢失。                   |

---

### **4. 速度**

| **特性** | **TCP**                                    | **UDP**                                  |
| -------- | ------------------------------------------ | ---------------------------------------- |
| **速度** | 较慢（因为有连接建立、确认、重传等机制）。 | 较快（无连接、无确认机制，传输轻量级）。 |

---

### **5. 开销**

| **特性** | **TCP**                            | **UDP**                              |
| -------- | ---------------------------------- | ------------------------------------ |
| **开销** | 较大：需维护连接状态和可靠性机制。 | 较小：无需维护连接状态，仅发送数据。 |

---

### **6. 应用场景**

| **特性**     | **TCP**                                                    | **UDP**                                                    |
| ------------ | ---------------------------------------------------------- | ---------------------------------------------------------- |
| **适用场景** | - 对数据完整性要求高的场景，如文件传输、邮件、网页加载等。 | - 对时效性要求高的场景，如视频直播、在线游戏、语音通话等。 |
|              | - 适用于可靠性比速度更重要的场景。                         | - 适用于速度比可靠性更重要的场景。                         |

---

### **7. 头部大小**

| **特性**     | **TCP**                                  | **UDP**                                                  |
| ------------ | ---------------------------------------- | -------------------------------------------------------- |
| **头部大小** | 20 字节或更多（有额外选项字段）。        | 8 字节，固定大小。                                       |
| **内容**     | 包括序列号、确认号、窗口大小等复杂信息。 | 仅包含最基本的信息：源端口、目标端口、数据长度、校验和。 |

---

### **8. 流量控制与拥塞控制**

| **特性**     | **TCP**                                                  | **UDP**          |
| ------------ | -------------------------------------------------------- | ---------------- |
| **流量控制** | 有流量控制机制，防止发送方发送过快导致接收方处理不过来。 | 无流量控制机制。 |
| **拥塞控制** | 有拥塞控制机制，动态调整传输速率，避免网络拥塞。         | 无拥塞控制机制。 |

---

### **总结对比表**

| **特性**     | **TCP**                        | **UDP**                        |
| ------------ | ------------------------------ | ------------------------------ |
| **连接**     | 面向连接，需要三次握手         | 无连接，直接发送数据           |
| **可靠性**   | 提供可靠传输，确保数据完整性   | 不保证可靠传输，可能丢包       |
| **传输顺序** | 确保按序传输                   | 不保证传输顺序                 |
| **速度**     | 较慢，适合高可靠性场景         | 较快，适合对时效性要求高的场景 |
| **开销**     | 开销较大，头部信息复杂         | 开销较小，头部信息简单         |
| **应用场景** | 文件传输、网页加载、电子邮件等 | 视频直播、在线游戏、语音通话等 |

---

### **适用场景**

1. **TCP：需要高可靠性的数据传输**

   - 文件传输协议（FTP）
   - 超文本传输协议（HTTP/HTTPS）
   - 电子邮件（SMTP、POP3、IMAP）
   - 远程登录（SSH、Telnet）

2. **UDP：需要快速传输的数据传输**
   - 视频直播（如 YouTube、Twitch）
   - 实时通信（如语音聊天、视频通话）
   - 在线游戏
   - 网络广播（如 DNS 查询、DHCP）

---

### **简单比喻**

- **TCP 就像打电话**：

  - 双方先建立连接（拨号和接通）。
  - 确认对方是否听到了每一句话。
  - 如果没听清，会要求重复。

- **UDP 就像发短信**：
  - 直接发送，不确认对方是否收到或收到的顺序。
  - 更快，但可能出现消息丢失或乱序。

## 4、HTTP 和 HTTPS 有什么区别？

HTTP（HyperText Transfer Protocol）和 HTTPS（HyperText Transfer Protocol Secure）是两种用于网络通信的协议，HTTPS 是 HTTP 的安全版本。它们的主要区别在于安全性、加密方式和数据传输的保护机制。以下是具体的差异：

---

### **1. 数据传输安全性**

| **特性**     | **HTTP**                                   | **HTTPS**                                    |
| ------------ | ------------------------------------------ | -------------------------------------------- |
| **安全性**   | 不安全，数据以明文传输，容易被拦截或篡改。 | 安全，数据经过加密传输，不容易被窃取或篡改。 |
| **数据加密** | 不加密，直接传输明文数据。                 | 使用 SSL/TLS 协议对数据进行加密。            |

---

### **2. 使用的协议**

| **特性**   | **HTTP**                           | **HTTPS**                                |
| ---------- | ---------------------------------- | ---------------------------------------- |
| **协议**   | 直接基于 TCP/IP 传输。             | 基于 TCP/IP，并通过 SSL/TLS 加密层传输。 |
| **安全层** | 无安全层，直接使用应用层协议通信。 | 在 HTTP 和 TCP 之间增加了 SSL/TLS 层。   |

---

### **3. 默认端口号**

| **特性**     | **HTTP**            | **HTTPS**            |
| ------------ | ------------------- | -------------------- |
| **默认端口** | 使用端口号 **80**。 | 使用端口号 **443**。 |

---

### **4. SSL/TLS 的使用**

| **特性**     | **HTTP**                 | **HTTPS**                                |
| ------------ | ------------------------ | ---------------------------------------- |
| **证书支持** | 不需要任何证书。         | 需要数字证书（SSL/TLS 证书）来验证身份。 |
| **身份验证** | 无法验证通信双方的身份。 | 通过证书验证服务器身份，增强信任。       |

---

### **5. 性能**

| **特性** | **HTTP**                     | **HTTPS**                                                    |
| -------- | ---------------------------- | ------------------------------------------------------------ |
| **性能** | 更快，没有加密和解密的开销。 | 略慢，存在加密和解密的开销，但现代硬件性能足以支持高速加密。 |

---

### **6. URL 形式**

| **特性**     | **HTTP**  | **HTTPS**  |
| ------------ | --------- | ---------- |
| **URL 前缀** | `http://` | `https://` |

---

### **7. 数据完整性**

| **特性**       | **HTTP**         | **HTTPS**                                      |
| -------------- | ---------------- | ---------------------------------------------- |
| **数据完整性** | 数据容易被篡改。 | 使用加密和校验，保证数据在传输过程中不被篡改。 |

---

### **8. SEO 优势**

| **特性**         | **HTTP**                         | **HTTPS**                                                   |
| ---------------- | -------------------------------- | ----------------------------------------------------------- |
| **搜索引擎友好** | 搜索引擎对 HTTP 网站的优待较少。 | HTTPS 是搜索引擎（如 Google）推荐使用的标准，对排名更友好。 |

---

### **9. 应用场景**

| **特性**     | **HTTP**                                   | **HTTPS**                                                    |
| ------------ | ------------------------------------------ | ------------------------------------------------------------ |
| **适用场景** | 适用于对安全性要求较低的场景，如静态网页。 | 适用于需要传输敏感信息的场景，如登录、支付、用户数据传输等。 |

---

### **10. 主要功能的对比**

| **特性**       | **HTTP**                           | **HTTPS**                        |
| -------------- | ---------------------------------- | -------------------------------- |
| **身份验证**   | 无身份验证，无法确定服务器真实性。 | 支持身份验证，确保服务器可信赖。 |
| **数据加密**   | 无数据加密，数据以明文传输。       | 数据加密，保护隐私和安全。       |
| **数据完整性** | 数据可能被拦截或篡改。             | 数据完整性得到保证，防止篡改。   |

---

### **总结对比表**

| **特性**     | **HTTP**                     | **HTTPS**                              |
| ------------ | ---------------------------- | -------------------------------------- |
| **安全性**   | 无加密，数据易被窃取或篡改。 | 加密传输，保证数据安全。               |
| **默认端口** | 80                           | 443                                    |
| **传输协议** | 无加密，仅基于 TCP 传输。    | 使用 SSL/TLS 保护数据传输。            |
| **性能**     | 无加密开销，速度快。         | 有加密开销，但硬件支持下速度差异小。   |
| **应用场景** | 静态网页、无敏感数据的通信。 | 需要传输敏感数据的场景，如支付、登录。 |
| **SEO 优势** | 对 SEO 无帮助。              | 对 SEO 有帮助，增强网站信任度。        |

---

### **选择 HTTPS 的原因**

1. **提高安全性**：防止数据被窃取或篡改。
2. **增强用户信任**：浏览器会对 HTTPS 网站显示安全锁图标，提高用户信任。
3. **符合行业标准**：现代网站几乎都要求使用 HTTPS，尤其是处理敏感数据时。
4. **SEO 优化**：搜索引擎更倾向于优先索引和推荐 HTTPS 网站。

### **总结**

- HTTP 是明文传输，适用于对安全性要求较低的场景。
- HTTPS 是加密传输，提供更高的安全性和数据完整性，是现代互联网的标准选择。

## 5、 简述 https 加密协议过程

### **HTTPS 加密过程**

HTTPS（HyperText Transfer Protocol Secure）通过 SSL/TLS（安全套接字层/传输层安全协议）来实现加密，确保数据在传输过程中安全。以下是 HTTPS 加密过程的详细说明：

---

### **1. 总体流程概述**

HTTPS 加密过程可分为以下几个步骤：

1. 客户端与服务器通过 **TCP 三次握手** 建立连接。
2. 开始 **SSL/TLS 握手过程**：
   - 确定加密算法和密钥。
   - 验证服务器身份（通过 SSL/TLS 证书）。
3. 建立加密通道：
   - 客户端和服务器协商生成会话密钥。
4. 数据传输：
   - 使用对称加密算法对数据进行加密后传输。

---

### **2. HTTPS 加密的详细过程**

#### **第一步：TCP 三次握手**

- HTTPS 首先通过 TCP 协议建立连接（与 HTTP 相同）。
- 客户端与服务器通过三次握手确认彼此可以正常通信。

---

#### **第二步：SSL/TLS 握手**

这是 HTTPS 与 HTTP 的主要区别所在。SSL/TLS 握手是为了建立一个安全的加密通道，包含以下步骤：

1. **客户端发起请求（Client Hello）**

   - 客户端向服务器发送一个 `Client Hello` 消息，内容包括：
     - 支持的加密算法（如 AES、RSA 等）。
     - 支持的 SSL/TLS 版本（如 TLS 1.2、TLS 1.3）。
     - 一个随机数（`Client Random`），用于后续生成会话密钥。

2. **服务器响应（Server Hello）**

   - 服务器收到 `Client Hello` 后，返回一个 `Server Hello` 消息，内容包括：
     - 确定的加密算法和 SSL/TLS 版本。
     - 另一个随机数（`Server Random`）。
     - 服务器的数字证书（SSL/TLS 证书），用于验证服务器身份。

3. **验证服务器身份**

   - 客户端通过以下方式验证服务器身份：
     - 检查证书是否由可信的证书颁发机构（CA）签发。
     - 检查证书是否过期。
     - 检查证书的域名是否匹配当前访问的域名。
   - 验证通过后，继续握手；如果失败，握手终止。

4. **生成会话密钥**
   根据使用的加密算法，生成会话密钥的过程可能有所不同：

   - **基于 RSA 的密钥交换：**

     1. 服务器证书中包含公钥。
     2. 客户端生成一个随机的预主密钥（`Pre-Master Secret`）。
     3. 客户端用服务器的公钥加密该预主密钥并发送给服务器。
     4. 服务器使用自己的私钥解密，得到预主密钥。

   - **基于 Diffie-Hellman（DH/ECDH）的密钥交换：**
     1. 双方协商交换公钥（不涉及私钥）。
     2. 使用各自的私钥和对方的公钥，计算出相同的会话密钥。

5. **生成最终会话密钥**

   - 客户端和服务器分别使用预主密钥、`Client Random` 和 `Server Random`，通过伪随机函数（PRF）生成最终的对称加密密钥。

6. **完成握手**
   - 客户端发送一条 `Finished` 消息，表明握手完成。
   - 服务器也发送一条 `Finished` 消息。
   - 握手完成后，安全通道建立。

---

#### **第三步：数据加密传输**

1. **对称加密传输数据**

   - 握手阶段生成的会话密钥是对称加密密钥，用于加密通信过程中的数据。
   - 客户端和服务器使用相同的密钥和加密算法（如 AES）加密和解密数据。

2. **数据完整性校验**
   - 在数据传输过程中，使用消息认证码（MAC，Message Authentication Code）来校验数据是否被篡改。

---

### **3. 加密技术中的关键点**

1. **对称加密**

   - 用于加密实际传输的数据。
   - 常见算法：AES（高级加密标准）。

2. **非对称加密**

   - 用于在握手阶段保护会话密钥的安全传输。
   - 常见算法：RSA、ECDSA。

3. **数字证书**

   - 验证服务器身份的凭证，由可信的证书颁发机构（CA）签发。
   - 包含服务器的公钥、颁发者信息、有效期等。

4. **伪随机函数（PRF）**
   - 用于生成会话密钥，结合随机数和预主密钥，确保密钥的唯一性和安全性。

---

### **4. 数据传输的安全性**

HTTPS 的安全性体现在以下几个方面：

1. **加密传输**：数据经过加密，防止被窃听。
2. **身份验证**：通过数字证书验证服务器身份，防止中间人攻击。
3. **数据完整性**：通过消息认证码（MAC）确保数据未被篡改。

---

### **5. 整体流程示意图**

```plaintext
客户端                          服务器
  |                                |
  | ------- TCP 三次握手 -------->  |
  | <------ TCP 三次握手 ---------  |
  |                                |
  | ------- Client Hello --------> |
  |                                |
  | <------- Server Hello -------- |
  | <---- 服务器证书（包含公钥）---- |
  |                                |
  | -- 客户端生成预主密钥，用公钥加密 --> |
  |                                |
  | <- 服务器解密预主密钥，生成会话密钥 - |
  |                                |
  | ------ 握手完成，传输数据 ------> |
  | <----- 加密传输的数据 ---------- |
```

---

### **总结**

HTTPS 加密的过程通过 SSL/TLS 协议，结合对称加密、非对称加密和数字证书技术，提供了：

- **加密传输**：防止数据被窃听。
- **身份验证**：确保通信双方的真实性。
- **数据完整性**：防止数据被篡改。

这种安全机制广泛用于网站登录、支付交易和敏感信息传输等场景，成为现代互联网的标准。

## 6、说说 TCP 的三次握手和四次挥手？

### **TCP 三次握手**

TCP（三次握手）是用来建立可靠的连接的过程，确保通信双方的状态是同步的。通过三次握手，客户端和服务器可以确认彼此的接收和发送能力。

#### **三次握手详细步骤**

1. **第一次握手（SYN）**

   - **客户端**：发送一个带有 `SYN` 标志的数据包给服务器。
   - **目的**：请求建立连接，并告知自己的初始序列号 `Seq = x`（假设为 x）。
   - **状态变化**：
     - 客户端进入 **SYN_SENT** 状态。

   ```plaintext
   客户端：SYN=1，Seq=x
   ```

2. **第二次握手（SYN-ACK）**

   - **服务器**：收到客户端的 `SYN` 数据包后，返回一个带有 `SYN` 和 `ACK` 标志的数据包。
     - `ACK` 用于确认客户端的 `SYN`，确认号 `Ack = x + 1`。
     - `SYN` 用于同步自己的初始序列号 `Seq = y`（假设为 y）。
   - **状态变化**：
     - 服务器进入 **SYN_RECEIVED** 状态。

   ```plaintext
   服务器：SYN=1，ACK=1，Seq=y，Ack=x+1
   ```

3. **第三次握手（ACK）**

   - **客户端**：收到服务器的 `SYN-ACK` 数据包后，发送一个带有 `ACK` 标志的数据包。
     - 确认号 `Ack = y + 1`，表明已收到服务器的 `SYN`。
     - 客户端的序列号可以是 `Seq = x + 1`。
   - **状态变化**：
     - 客户端进入 **ESTABLISHED** 状态。
     - 服务器收到该 `ACK` 后也进入 **ESTABLISHED** 状态。

   ```plaintext
   客户端：ACK=1，Seq=x+1，Ack=y+1
   ```

#### **三次握手示意图**

```plaintext
客户端                            服务器
  | -------- SYN (Seq=x) -------> |
  | <--- SYN-ACK (Seq=y, Ack=x+1) |
  | --------- ACK (Ack=y+1) ----> |
```

---

### **TCP 四次挥手**

四次挥手是 TCP 连接断开时的过程，用来保证双方都能优雅地释放资源。

#### **四次挥手详细步骤**

1. **第一次挥手（FIN）**

   - **客户端**：发送一个带有 `FIN` 标志的数据包，表示不再发送数据，但仍能接收数据。
   - **目的**：告知服务器 "我要关闭连接了"。
   - **状态变化**：
     - 客户端进入 **FIN_WAIT_1** 状态。

   ```plaintext
   客户端：FIN=1，Seq=u
   ```

2. **第二次挥手（ACK）**

   - **服务器**：收到 `FIN` 后，返回一个带有 `ACK` 标志的数据包，确认号 `Ack = u + 1`。
   - **目的**：确认客户端的关闭请求，但服务器可能还有未发送完的数据。
   - **状态变化**：
     - 服务器进入 **CLOSE_WAIT** 状态。
     - 客户端进入 **FIN_WAIT_2** 状态。

   ```plaintext
   服务器：ACK=1，Ack=u+1
   ```

3. **第三次挥手（FIN）**

   - **服务器**：完成剩余数据传输后，发送一个带有 `FIN` 标志的数据包，表示服务器也要关闭连接。
   - **目的**：告知客户端 "我也要关闭连接了"。
   - **状态变化**：
     - 服务器进入 **LAST_ACK** 状态。

   ```plaintext
   服务器：FIN=1，Seq=v
   ```

4. **第四次挥手（ACK）**

   - **客户端**：收到服务器的 `FIN` 后，发送一个带有 `ACK` 标志的数据包，确认号 `Ack = v + 1`。
   - **目的**：确认服务器的关闭请求。
   - **状态变化**：
     - 客户端进入 **TIME_WAIT** 状态，等待一段时间（通常为 2 倍的最大报文段生存时间）以确保服务器收到 ACK 后关闭连接。
     - 服务器收到 ACK 后立即进入 **CLOSED** 状态。

   ```plaintext
   客户端：ACK=1，Ack=v+1
   ```

#### **四次挥手示意图**

```plaintext
客户端                            服务器
  | -------- FIN (Seq=u) -------> |
  | <--------- ACK (Ack=u+1) ---- |
  | <-------- FIN (Seq=v) ------- |
  | --------- ACK (Ack=v+1) ----> |
```

---

### **为什么是三次握手和四次挥手？**

1. **三次握手原因**：

   - 确保双方都能同步发送和接收能力：
     - 第一次握手：客户端确认服务器存在。
     - 第二次握手：服务器确认客户端发送能力，并告知自己接收能力。
     - 第三次握手：客户端确认服务器接收能力，通信正式建立。

2. **四次挥手原因**：
   - TCP 是全双工协议，连接断开需要双方各自关闭自己的传输通道：
     - 两次挥手关闭客户端发送通道。
     - 再两次挥手关闭服务器发送通道。

---

### **状态变化总结**

#### **三次握手状态变化**

| 客户端状态             | 服务端状态                 |
| ---------------------- | -------------------------- |
| CLOSED → SYN_SENT      | CLOSED → SYN_RECEIVED      |
| SYN_SENT → ESTABLISHED | SYN_RECEIVED → ESTABLISHED |

---

#### **四次挥手状态变化**

| 客户端状态               | 服务端状态               |
| ------------------------ | ------------------------ |
| ESTABLISHED → FIN_WAIT_1 | ESTABLISHED → CLOSE_WAIT |
| FIN_WAIT_1 → FIN_WAIT_2  | CLOSE_WAIT → LAST_ACK    |
| FIN_WAIT_2 → TIME_WAIT   | LAST_ACK → CLOSED        |
| TIME_WAIT → CLOSED       |                          |

---

### **总结**

- **三次握手** 用于建立可靠连接，确保双方通信能力同步。
- **四次挥手** 用于优雅断开连接，保证双方数据传输完成。
- 三次握手和四次挥手都是 TCP 协议保证可靠传输的核心机制，体现了其面向连接和可靠性的特点。

## 7、OSI 七层模型是什么？

OSI（开放式系统互联）模型是由国际标准化组织（ISO）提出的网络通信参考模型，将网络通信过程分为七个层次。每一层都定义了特定的功能，以确保不同系统之间的互联互通。以下是对 OSI 七层模型的详细介绍：

1. **物理层（Physical Layer）**：负责在物理媒体上传输原始的比特流，定义硬件设备的标准，如电缆、插头、电压等。

2. **数据链路层（Data Link Layer）**：提供节点间的数据传输，负责帧的同步、差错检测与纠正，以及介质访问控制。

3. **网络层（Network Layer）**：负责路径选择和逻辑地址寻址，实现数据包从源到目的地的传输。

4. **传输层（Transport Layer）**：提供端到端的通信服务，确保数据的完整性和可靠传输，常见协议包括 TCP 和 UDP。

5. **会话层（Session Layer）**：管理会话控制，负责建立、维护和终止通信会话。

6. **表示层（Presentation Layer）**：处理数据的表示形式，确保不同系统之间的数据格式一致，包括数据加密、解密和压缩等功能。

7. **应用层（Application Layer）**：直接面向用户，提供网络服务，如电子邮件、文件传输和远程登录等。

需要注意的是，OSI 模型是一种理论模型，用于指导网络协议的设计和理解。在实际应用中，互联网主要采用 TCP/IP 协议栈，其分层与 OSI 模型有所不同。TCP/IP 模型通常分为四层：网络接口层、互联网层、传输层和应用层。尽管如此，OSI 模型仍然是理解网络通信原理的重要工具。

通过将网络通信过程分层，OSI 模型有助于标准化网络协议的设计，促进不同厂商设备之间的互操作性，并简化网络故障的诊断和排除。

以下是 OSI 七层模型的图示及每一层的功能说明：

```plaintext
+-------------------+
| 应用层（第七层）  |
| - 提供网络服务    |
|   给应用程序      |
| - 协议示例：HTTP  |
|   、FTP、SMTP     |
+-------------------+
| 表示层（第六层）  |
| - 数据格式转换    |
| - 加密与解密      |
| - 数据压缩        |
+-------------------+
| 会话层（第五层）  |
| - 管理会话控制    |
| - 负责建立、维持  |
|   和终止会话      |
+-------------------+
| 传输层（第四层）  |
| - 提供端到端的    |
|   传输服务        |
| - 确保数据完整性  |
| - 协议示例：TCP   |
|   、UDP           |
+-------------------+
| 网络层（第三层）  |
| - 路由选择        |
| - 逻辑地址寻址    |
| - 协议示例：IP    |
+-------------------+
| 数据链路层（第二层）|
| - 节点间数据传输  |
| - 帧同步          |
| - 差错检测与纠正  |
+-------------------+
| 物理层（第一层）  |
| - 传输原始比特流  |
| - 定义硬件标准    |
| - 如电缆、插头    |
|   、电压等        |
+-------------------+
```

每一层都有其特定的功能，确保网络通信的顺利进行。需要注意的是，实际应用中，互联网主要采用 TCP/IP 协议栈，其分层与 OSI 模型有所不同。TCP/IP 模型通常分为四层：网络接口层、互联网层、传输层和应用层。尽管如此，OSI 模型仍然是理解网络通信原理的重要工具。

## 8、TCP 超时重传机制是为了解决什么问题？

TCP（传输控制协议）的超时重传机制旨在解决数据包在网络传输过程中可能丢失的问题。在 TCP/IP 网络中，数据被分割成小的数据包进行传输，这些数据包可能会因为网络拥堵、硬件故障、软件错误等原因在到达目的地之前丢失。为了确保数据的可靠传输，TCP 采用了超时重传机制。

**超时重传机制的工作原理：**

1. **发送数据包：** 当 TCP 发送一个数据包时，它会启动一个定时器，等待接收方确认（ACK）该数据包的到达。

2. **确认机制：** 接收方在收到数据包后，会发送一个确认消息回给发送方。

3. **超时检测：** 如果发送方在预定的时间内没有收到确认消息，它会认为数据包丢失，并重新发送该数据包。

4. **重传：** 发送方重新发送数据包，并重新启动定时器。

5. **调整超时时间：** TCP 会根据网络状况动态调整超时时间（通常称为 RTO，Retransmission Timeout）。这个时间是基于往返时间（RTT，Round-Trip Time）的估计。

6. **避免无限重传：** TCP 通常有一个限制，防止数据包无限重传。如果重传次数超过一定阈值，TCP 可能会报告错误并关闭连接。

通过上述机制，TCP 能够在网络出现丢包的情况下，确保数据的可靠传输。

## 9、TCP/IP 四层模型是什么？

TCP/IP 四层模型是用于描述计算机网络通信协议的框架，主要包括以下四层：

1. **应用层（Application Layer）：** 直接面向用户，提供网络服务，如 HTTP、FTP、SMTP 等。

2. **传输层（Transport Layer）：** 负责端到端的数据传输，确保数据的可靠性和完整性，主要协议有 TCP 和 UDP。

3. **网络层（Internet Layer）：** 负责数据包的路由和转发，主要协议是 IP（Internet Protocol）。

4. **网络接口层（Network Interface Layer）：** 负责在物理网络上发送和接收数据帧，处理硬件地址和物理传输介质的细节。

需要注意的是，TCP/IP 模型与 OSI 七层模型有所不同，后者更为详细地划分了网络通信的各个层次。

## 10、从网络角度来看，用户从输入网址到网页显示，期间发生了什么？

当用户在浏览器中输入网址并按下回车时，浏览器会经历以下步骤，从网络角度获取并显示网页内容：

1. **DNS 解析：**

   - 浏览器需要将用户输入的网址（如 www.example.com）转换为服务器的 IP 地址。浏览器会首先查找本地 DNS 缓存，如果缓存中没有该域名的 IP 地址，浏览器会向 DNS 服务器发送请求来解析该域名。

2. **建立 TCP 连接：**

   - 获取到 IP 地址后，浏览器会与目标服务器建立一个 TCP 连接。为了保证连接的可靠性，TCP 会进行三次握手过程：
     - 第一次：客户端发送一个 SYN 请求包。
     - 第二次：服务器返回一个 SYN-ACK 响应包。
     - 第三次：客户端再发送一个 ACK 确认包，连接建立完成。

3. **发送 HTTP 请求：**

   - TCP 连接建立后，浏览器向服务器发送一个 HTTP 请求，请求网页的资源（如 HTML 文件、图片、CSS 文件等）。如果是 HTTPS 请求，还会进行 TLS/SSL 握手，保证数据加密传输。

4. **服务器处理请求：**

   - 服务器接收到请求后，会处理并生成响应内容，通常是网页的 HTML、CSS、JavaScript 代码，以及相关的图片和其他资源。服务器将这些内容作为 HTTP 响应返回给浏览器。

5. **接收 HTTP 响应：**

   - 浏览器接收到服务器的 HTTP 响应后，开始解析 HTML 内容。浏览器会根据 HTML 中的标签、链接和嵌入的资源来决定后续操作。

6. **解析和渲染页面：**

   - 浏览器解析 HTML 文档，构建 DOM（文档对象模型）树。同时，解析 CSS，生成 CSSOM 树，最后将这两者合并成渲染树（Render Tree）。
   - 如果页面中有 JavaScript，浏览器会执行 JavaScript 代码，可能会改变 DOM 或 CSSOM 树，进而影响页面的显示。

7. **资源加载：**

   - 如果页面包含外部资源（如图片、JavaScript 文件、CSS 文件等），浏览器会进一步向服务器发送请求加载这些资源。

8. **关闭 TCP 连接：**

   - 当所有资源加载完成，浏览器和服务器通过 TCP 协议的四次挥手关闭连接，确保数据传输完毕。

9. **页面显示：**
   - 最终，浏览器将渲染的页面显示给用户，用户可以看到网页的完整内容。

这个过程包括 DNS 解析、建立 TCP 连接、发送 HTTP 请求和响应、加载资源以及页面渲染等多个步骤，其中的每一步都涉及网络协议和数据传输的详细操作。
