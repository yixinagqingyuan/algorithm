/** @format */

// 最长递增子序列
// 这一题也是考动态规划
// 动态规划思路主要就是做一件事，找到关联公式，也就是逻辑公式
const lengthOfLIS = (nums) => {
  // 所以我们首先的思路，要有 dp
  const dp = []
  // 然后就是要开始建立，dp[i] dp[i-1]和 dp[i-2] 的关系
  // 接下来就可以 for 循环
  for (let i = 0; i < nums.length; i++) {
    // 然后就该找关系，怎么找呢，和简单，要找最长的
    // 于是我们遍历到当前这个，比之前的哪个大，大的话就开始+1
    // 接下来就给他存到 dp 里头去
    // 这种情况其实应该双重 for 循环
    // 为什么嘞，因为我要找到这个之前的所有元素去比较
    // 如果之前有比之前更大的，那么就得给这个给加起来
    // 初始化的时候 dp 当前的 i 一定是1 最小是一
    dp[i] = 1
    // 然后就该比较了
    for (j = 0; j < i; j++) {
      // 这时候要判断 nums i 和j 的大小比较了
      // 这里的核心就是我之前的累计的最长递归，然后一个个去比较
      // 这里所谓的动态规划，就是我当前的这个是根据前面的已有数据来的，就是动态规划
      if (nums[i] > nums[j]) {
        dp[i] = Math.max(dp[j] + 1, dp[i])
      }
    }
  }
  return Math.max(...dp)
}
