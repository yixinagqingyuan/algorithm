/** @format */

//给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。返回容器可以储存的最大水量。
// 这是一个有意思的题，他说了一大堆屁话，说白了就是要根据横坐标纵坐标求一个最大面积
// 可以用双指针套路做
const maxArea = (nums) => {
  // 这个题目的思路其实就用双指针，做是最合理的，当然还有一种方式是疯狂比例，算出来每一个的大小
  // 然后来比较，当然这样就是一个双重 for循环，很不体面，于是，我们还是双指针吧
  // 既然是双指针套路，当然得有两个指针,一个指向开头，一个指向结尾
  let left = 0
  let right = nums.length - 1
  // 这时候因为是双指针，那么必然老老实实的用 for 循环是不可能了要用 while
  let max = 0
  while (left < right) {
    // 然后我们就开始学模算计 要求最大值，怎么求呢?用 Math.max 啊
    max = Math.max(max, Math.min(nums[left], nums[right]) * (right - left))
    // 然后我们就开始移动指针，移动指针的时候有个诀窍,那就是我们每次移动的时候都要移动值小的一方
    // 原因很简单，他这个值小，后续计算面积的时候都是以你为准，如果碰见个比你高的，但横坐标的宽度减小了，
    // 他的面基就不可能大，倘若，碰见个比你更小的，那么就更离谱了
    //所以 综上所述，一定要给小的干掉才行，也就是干掉已知的小的内容 ，并且保证 left 和 right 一直在移动
    // 倘若后续移动之后碰见更小的了，这是我们预见不到的，但是他虽然算出面积了，但是会在后续被淘汰掉
    // 其实理论上来说，应该是，我左边的不动， 右边的遍历到底，左边的不动右边的遍历到底
    // 但这样就变成了，双重 for 循环了，双指针其实就是规避了双重 for 循环中产生的多余的项目
    if (nums[left] < nums[right]) {
      left++
    } else {
      right--
    }
  }
}
// 他这个，什么意思呢，就是 我第一个位置，高度是1，第二个位置高度是 8。。。。。。
maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7])
