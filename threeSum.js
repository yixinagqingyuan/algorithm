/** @format */

//给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请

//你返回所有和为 0 且不重复的三元组。

//注意：答案中不可以包含重复的三元组。

// 这一题的意思是什么，找三个数加一块是不是等于 0， 并且这三个数还不能相等

const threeSum = (nums) => {
  // 这一题的本质，很简单，就是找三个相加的一块的值等于 0 就是，然后我为了找到合适的值
  // 我们只需要 从前到后遍历，然后拿到第一个值之后，在后面的值里头去挑等于零的
  // 最终输出结果，至于为什么往后挑，而不是往前挑，很简单啊，前头有可能有重复的，因为我当遍历到前头的时候
  // 再往后挑，这样当我遍历到后头的时候，如果往前挑，就有可能找到之前被挑过的一模一样的三个数
  // 于是我们开始尝试一下
  // 在开始之前，我们首先得弄个数组存结果，所谓工欲善其事，必先利其器
  const result = []
  // 然后我们需要排除一些特殊情况，比如他数组压根他么凑不够三个的情况
  if (nums.length < 3) {
    return result
  }
  // 然后就得开始准备了，准备什么呢？
  // 准备排序啊，为什么要排序，原因很简单，我们能够通过排序来规避一些无所屌谓的遍历，因为我们是要找0，如果你上来就大于零，那指定是废了，就不用往下处理了
  // 注意从小到大啊
  nums.sort((a, b) => a - b)
  // 然后就要开始，准备遍历,遍历致所有是要-2 原因也很简单，我们要从这个数里头去找后头的数做匹配，你遍历到-1 了，后头没数了
  // 你还搞个屁啊
  for (let i = 0; i < nums.length - 2; i++) {
    // 这个时候我们之前排序的威力就显示出来了，这一招能让你平静的内心里吗掀起波澜，真特么聪明，人嘛，都是情绪动物
    if (nums[i] > 0) {
      // 这里还有个技巧，为什么是 break 因为啊，我这个大于零，那么说明后头的也都是大于 0 ，所以，就没必要了
      // 直接退出循环就行了，这里你就发现，一个小小的算法，到处都是局，到处都是智慧，到处都是心思，玛德，真特么笨，你内心的波澜可能瞬间就变成忐忑不安
      break
    }
    // 接下来，还要做一件事情，就是判断重复，也就是我当前的这个是 1 下一个还是 1， 那最后 选到的必定是重复的所以我们要处理一下，
    // 碰见这种情况，要前进一步并且什么都不做
    if (nums[i] == nums[i - 1]) {
      // 退出当前循环就行这样就前进一步了
      continue
    }
    // 然后做什么事情呢？
    // 当然是搜寻匹配的内容，要搜寻内容就要用循环 while 循环
    // while 循环当然有条件，就是左右条件，我们一定要给所有的后续的选项找完
    let left = i + 1
    let right = nums.length - 1
    // 条件是左边小于右边就行
    // 注意，这里的设计依然很巧妙，因为我们不是每一次，left++，right--
    // 而是每次只处理一个的++或者--
    // 并且还有结合排序后的大小，所以这是非常难的
    while (left < right) {
      // 我们开始找了
      let sun = nums[i] + nums[left] + nums[right]
      if (sun == 0) {
        // 当等于0 的时候说明找到了
        // 此时我们要双指针的原则移动，left++ right-- ，必须同时移动
        // 为什么呢？ 原因很简单， 他有排序啊，left 必须++ right 必须-- 才有可能能等于 0
        // 我们先给结果 push 进去
        result.push([nums[i], nums[left], nums[right]])
        // 保存到数组之后就得想移动必须全部移动
        left++
        right--
        // 这个时候还需要去重，为什么呢？ 因为，你从里头挑也有可能是重复的
        // 我们怎么能多次去重呢，还是 while
        // 第一次是不需要 while 判断重复的，我们要从第二个开始判断
        // 判断当前的这个是否是上一个一样，而不是下一个
        while (nums[left] === nums[left - 1]) {
          left++
        }
        while (nums[right] === nums[right + 1]) {
          right--
        }
      } else {
        // 如果不等于0 说明并没有找到，当并没有找到的时候，我们要在去判断是 left ++ 还是 right--
        // 这种情况，就能遍历到，我们随便挑的情况，但是避免了随便挑出现了不可能的情况
        if (sun > 0) {
          // 如果>0 了就说明太大了，由于有排序，所以就需要 right--
          right--
        } else {
          // 这个时候就是<0 所以需要 left++
          left++
        }
      }
    }
  }
  console.log(result)
}
threeSum([-1, 0, 1, 2, -1, -4])
