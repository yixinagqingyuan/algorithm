/** @format */

//合并两个有序数组
// 这一题看似简单，实则费劲，因为你要排序两个数组，最笨的办法是先合并在排序
// 这是最简单的绝活，但是，面试官显然不会让你这么干，因为这玩意你会别人也会
// 那他为啥要你不要别人呢？ 除非你长得好看
// 所以，我们必须另辟蹊径，也就是将第二个数组中的内容插入到第一个
const twoNumConcat = (nums1, m, nums2, n) => {
  // 如果要将第二个数组插入到第一个，那么我们就需要算出来很多东西
  // 首先就是总数组长度
  let len = m + n
  let len1 = m - 1
  let len2 = n - 1
  // 然后就开始 for 循环,这样能方便插入
  // 遍历的时候不能改变原数组，并且还要从后往前 遍历，且慢且慢，还有一个关键信息
  // 他是两个有序数组 所以，我们 要做比较啊，还要将 m 和 n 的 length 记下来
  for (let i = len - 1; i >= 0; i--) {
    // 这时候就要开始比较了.且慢且慢，还有个关键信息，如果由于是将 nums2 插入到 nums1
    // 所以你要保证一点，nums2要一直有啊也就是len2 要保证大于等于 0
    // 当小于0 的时候我们需要直接将 nums1 赋值就行了，因为你插入已经没有了，剩下的指定是 nums1 的排列啊
    if (len2 < 0) {
      nums1[i] = nums1[len1]
      len1--
      continue
    }
    // 此时就还有可能有一个疑问，就是，如果我由于 nums2 的插入，给 nums1 吃了咋整，
    // 这样 nums1 不就黄了吗，在挪动位置的时候就不对了
    // 因为其实这个情况不可能发生，为啥嘞，因为我我们选项被吃掉的情况不会发生
    //  那就是当我比较到某一个位置的时候， 假设 ，我这个位置要拿 nums1 中的 选项去填坑
    // 当这个选项被填坑以后，他就要前移动一位，那么此时这个数据就不可能在比较了
    // 也就是不会有nums2 中的选项跟他比较了
    // 然后此时可能还有一个疑问，就是我 nums2 的位置给当前的这个len1 的某一个位置占了
    // 那么此时再比较的时候岂不是还是错的？
    // 不过这种情况也不会发生，因为压根就不会读到len1 和 len 的位置相同的情况
    // 因为，数组中一共 比如一共六个数，我假设 nums2 最大，那么都不可能填到nums1 中来
    // 假设填到里头来了，替换掉了 nums1 中的一个，那么就说，我前头已经有 nums1 被填进去了至少一个
    // 那么他本质上来讲，len1 就会被减到 比当前替换掉靠前的位置
    if (nums1[len1] > nums2[len2]) {
      // 比较出来了就给他赋值到最后去
      nums1[i] = nums1[len1]
      len1--
    } else {
      nums1[i] = nums2[len2]
      len2--
    }
  }
  console.log(nums1)
}

twoNumConcat([1, 2, 4, 0, 0, 0], 3, [3, 5, 6], 3)
